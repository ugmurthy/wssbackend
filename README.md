---
title: Real-Time Async Service Backend
date: 2026-02-13
author: grok-4 in collaboration with @ugmurthy
---

# Real-Time Async Service Backend

A high-performance backend infrastructure using raw WebSockets for bidirectional communication, BullMQ for async job queuing, and Bun as the runtime. Designed for long-running services with instant push notifications (no polling).

> **Note**: (TAME->AI->PRD) Here is product requirement generated by AI but Thoughts-Are-MinE (I am calling this TAME) [@ugmurthy](https://github.com/ugmurthy) to provide a opportunity to budding developers to learn and build professionally. Now is the most exciting time to learn and build with coding agents - give it you best shot and lets see where this goes. If you like this idea, please give a star to this repo.

## Prerequisites

- **Bun** (v1.3+ recommended): Install from [bun.sh](https://bun.sh)
  ```bash
  curl -fsSL https://bun.sh/install | bash
  ```

````

- **Docker**: For running Redis (official image)

## Project Structure (Recommended)

```
project-root/
├── gateway/          # WebSocket gateway (Fastify + @fastify/websocket)
│   ├── package.json
│   └── src/index.ts
├── worker/           # BullMQ workers (separate process)
│   ├── package.json
│   └── src/worker.ts
├── shared/           # Optional: Shared types, utils, message schemas
├── docker-compose.yml
└── .env              # Shared environment variables
```

## Installation

1. Clone the repo and navigate to root.

2. Install dependencies in each package (Bun is used for fast installs):

   ```bash
   # In gateway/
   cd gateway
   bun install

   # In worker/
   cd ../worker
   bun install
   ```

   Key dependencies (add to each `package.json` as needed):

   ```json
   {
     "dependencies": {
       "fastify": "^4.28.0",
       "@fastify/websocket": "^8.3.0",
       "bullmq": "^5.0.0",
       "ioredis": "^5.4.0",
       "zod": "^3.23.0" // Optional: for message validation
     }
   }
   ```

3. Create a shared `.env` file (at project root):
   ```
   REDIS_URL=redis://localhost:6379
   PORT=3000                  # Gateway port
   JWT_SECRET=your-secret      # For auth
   ```

## Running Redis (Docker)

Use the official Redis image via Docker Compose (recommended for consistency):

Create `docker-compose.yml` at root:

```yaml
version: "3.8"
services:
  redis:
    image: redis:latest
    container_name: async-backend-redis
    ports:
      - "6379:6379"
    restart: unless-stopped
```

Start Redis:

```bash
docker compose up -d
```

(Or one-off: `docker run --name async-redis -p 6379:6379 -d redis:latest`)

## Running the Application

1. **Start the Gateway** (handles WebSocket connections):

   ```bash
   cd gateway
   bun run src/index.ts   # Or bun dev if using scripts
   ```

2. **Start Workers** (process jobs – run multiple for scaling):

   ```bash
   cd worker
   bun run src/worker.ts
   ```

   Run additional worker instances in separate terminals for parallelism.

## Development Notes

- Implement heartbeats (ping/pong) manually on WebSocket connections.
- Connection mapping: In-memory `Map<jobId, Set<WebSocket>>` in gateway for targeted pushes.
- Test with sample clients from the [`websocket-backend.md`](./websocket-backend.md)
- Test with samele workers see [`WORKERS.md`](./WORKER.md)

## Questions to ponder

Should this be a monorepo setup (single package.json) or separate packages for gateway/worker as shown?

## CONTRIBUTING

We welcome contributions! Whether it's bug fixes, new features, documentation improvements, or additional service examples, your help is appreciated.

This project follows the [Conventional Commits](https://www.conventionalcommits.org/) specification for commit messages.

### How to Contribute

1. **Fork the Repository**
   Click the "Fork" button on the top-right of the GitHub repo page to create your own copy.

2. **Clone Your Fork**

   ```bash
   git clone https://github.com/your-username/real-time-async-backend.git
   cd real-time-async-backend
   ```

3. **Create a Branch**
   Use a descriptive name:

   ```bash
   git checkout -b feature/my-new-feature
   # or
   git checkout -b fix/issue-description
   ```

4. **Make Your Changes**
   - Follow existing code style (Prettier/ESLint if added later).
   - Keep changes focused and atomic.
   - Add or update tests if applicable.
   - Update documentation/README where needed.

5. **Commit and Push**
   Use clear commit messages:

   ```bash
   git add .
   git commit -m "feat: add progress reporting to worker"
   git push origin feature/my-new-feature
   ```

6. **Open a Pull Request**
   - Go to the original repository on GitHub.
   - Click "New Pull Request" and compare your branch.
   - Provide a clear title and description:
     - What the PR does
     - Why it's needed
     - Any related issues (e.g., "Closes #123")
   - Link to any relevant issues.

7. **Code Review**
   - Maintainers will review your PR.
   - Be responsive to feedback and make requested changes.

### Guidelines

- **Issues First**: For significant changes, open an issue to discuss before submitting a PR.
- **Sign Commits**: If using GPG, sign your commits.
- **Respect the Code of Conduct**: Be kind and professional (follow Contributor Covenant if adopted).
- **Testing**: Ensure the project still runs (gateway + worker + Redis).

Thank you for contributing!
````
